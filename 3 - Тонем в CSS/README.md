## Псевдоклассы, `hover` и интерактивность в CSS

### 1. Что такое псевдокласс

**Псевдокласс** — это «виртуальное» состояние элемента, которое не записано в HTML,
но определяется поведением пользователя или особенностями структуры.

Пример:

```css
a:hover { color: red; }
```

Означает: «Когда курсор находится над ссылкой — покрасить её в красный».


### 2. Основные псевдоклассы

| Псевдокласс | Что делает                                                    | Пример                                        |
| ----------- | ------------------------------------------------------------- | --------------------------------------------- |
| `:hover`    | Наведение курсора на элемент                                  | `.cell:hover { background: gold; }`           |
| `:active`   | Нажатие на элемент (во время клика)                           | `.button:active { transform: scale(0.95); }`  |
| `:focus`    | Элемент в фокусе (например, поле ввода после клика)           | `input:focus { border-color: blue; }`         |
| `:checked`  | Отмеченный чекбокс или радио-кнопка                           | `#box:checked + label { background: green; }` |
| `:not(...)` | Отрицание (применить к элементам, не удовлетворяющим условию) | `.cell:not(.wall) { cursor: pointer; }`       |
| `:has(...)` | Проверяет, есть ли внутри/рядом элемент с нужным состоянием   | `.lab:has(.wall:hover) { background: pink; }` |



### 3. Как работает `:hover`

Псевдокласс `:hover` срабатывает, когда курсор находится над элементом.

Пример:

```css
.wall:hover {
  background: tomato;
}
```

**Важно:** `:hover` работает только с теми элементами, у которых `pointer-events` не выключен.

### 4. Как менять стили *других элементов* при наведении

Иногда нужно, чтобы при наведении на один элемент что-то происходило с другим.
Например — при наведении на стену меняется картинка внизу (наш случай).

Старый способ — через JavaScript,
но теперь в CSS есть мощный псевдокласс **`:has()`**.

#### Пример:

```css
.lab:has(.wall:hover) ~ .picture {
  background-image: url("другая_картинка.jpg");
}
```

**Как это читается:**

> Найди элемент `.lab`, в котором в данный момент курсор наведен на `.wall`,
> и примени стили к следующему соседу `.picture`.

Так мы можем обойтись **без JS**, используя только CSS.



### 5. Как срабатывает `:checked`

Этот псевдокласс относится к `input` типа `checkbox` или `radio`.
Он показывает, отмечен ли элемент.

```html
<input type="checkbox" id="hit">
<label for="hit">Попасть в цель</label>
```

```css
#hit:checked + label {
  background: green;
}
```

После клика по метке (label) чекбокс станет отмеченным, и фон метки изменится.

В играх это удобно, чтобы **фиксировать результат** —
например, в лабиринте можно «включать» победу по клику на финиш.



### 6. Псевдоэлементы `::before` и `::after`

Эти штуки позволяют вставлять **дополнительные элементы** в HTML
(визуально), не меняя сам код.

Пример:

```css
.cell::after {
  content: "";
  position: absolute;
  border: 1px solid gray;
}
```

* `content:` — обязательно, даже если пустое;
* используются для подсветки, украшений, стрелок, рамок и т.п.



### 7. Применение к задаче «Лабиринт»

В задаче про лабиринт нам нужны три вещи:

1. **Наведение (`:hover`)** — чтобы определять, на какой клетке находится курсор.

   ```css
   .wall:hover { background: #444; }
   ```

2. **Контекстное условие (`:has()`)** — чтобы менять картинку,
   когда курсор наведен на любую стену.

   ```css
   .lab:has(.wall:hover) ~ .picture {
       background-image: url("scary.jpg");
   }
   ```

3. **Псевдоэлементы (`::before`/`::after`)** — чтобы добавить рамку,
   текст подсказки или эффект свечения без дополнительных тегов.


### 8. Как браузер понимает всё это

1. Сначала курсор попадает в `.wall` → срабатывает `:hover`.
2. CSS-движок видит, что `.lab` *has* `.wall:hover` → активирует правило.
3. Сосед `.picture` меняет фон.
4. Когда курсор уходит — состояние `:hover` исчезает,
   и картинка возвращается к исходной.



### 9. Ограничения и советы

* `:has()` поддерживается **во всех современных браузерах**, кроме старых Safari и IE.
  Проверить можно на [caniuse.com/has-css](https://caniuse.com/css-has).
* Не злоупотребляй `:has()` на больших страницах — он «тяжёлый».
* Если нужно действие **по клику**, используй `:checked` и `label for=...`.
* Если нужно действие **по наведению**, используй `:hover` и `:has()`.



### 10. Мини-пример: ядро лабиринта

```html
<div class="lab">
  <div class="wall"></div>
  <div class="path"></div>
</div>
<div class="picture"></div>
```

```css
.wall:hover { background:#444; }

.lab:has(.wall:hover) ~ .picture {
  background-image:url("scary.jpg");
}
```

## CSS-комбинаторы (напоминание): `>`, `+`, `~`, ` `

Комбинаторы показывают **отношения между элементами**: кто кому родитель, сосед или потомок.

### **1. Потомок (пробел)**

Выбирает **всех потомков любого уровня** (вложенных на любую глубину).

```html
<div class="card">
  <p>Абзац 1 — прямой потомок</p>
  <div>
    <p>Абзац 2 — вложенный глубже</p>
  </div>
</div>

<style>
.card p {
  color: darkblue; /* выделятся оба <p> */
}
</style>
```

Оба `<p>` окрасились, даже если один глубже — потому что пробел ищет всех потомков.



### **2. Прямой ребёнок (`>`)**

Выбирает **только элементы, которые находятся на первом уровне внутри родителя**.

```html
<div class="menu">
  <p>Элемент 1 (первый уровень)</p>
  <div>
    <p>Элемент 2 (вложен глубже)</p>
  </div>
</div>

<style>
.menu > p {
  color: darkgreen; /* сработает только для первого <p> */
}
</style>
```

`<p>` внутри вложенного `<div>` не окрасился — он не прямой ребёнок `.menu`.


### **3. Смежный сосед (`+`)**

Выбирает **элемент, который идёт сразу после указанного**
(оба должны быть соседями и иметь одного родителя).

```html
<h2>Заголовок</h2>
<p>Этот абзац сразу после заголовка — изменится</p>
<p>А этот нет — между ними уже был другой элемент</p>

<style>
h2 + p {
  color: darkred; /* выделится только первый <p> */
}
</style>
```

Работает **только для первого соседа**, который стоит **сразу** за `<h2>`.

### **4. Общие соседи (`~`)**

Выбирает **всех элементов того же уровня**, которые находятся **после** заданного.

```html
<h3>Точка отсчёта</h3>
<p>Абзац 1</p>
<p>Абзац 2</p>

<style>
h3 ~ p {
  color: purple; /* оба <p> после <h3> станут фиолетовыми */
}
</style>
```

Все абзацы после `<h3>` (на одном уровне вложенности) будут выбраны.

### **5. Сравнение в одной картинке**

| Комбинатор | Что значит                 | Пример      | Что выделяет                    |
| ---------- | -------------------------- | ----------- | ------------------------------- |
| `A B`      | Потомки любого уровня      | `.menu p`   | Все `p` внутри `.menu`          |
| `A > B`    | Прямые дети                | `.menu > p` | Только `p` сразу внутри `.menu` |
| `A + B`    | Сосед, стоящий сразу после | `h2 + p`    | Первый `p` после `h2`           |
| `A ~ B`    | Все следующие соседи       | `h2 ~ p`    | Все `p` после `h2`              |



### **6. Применение в мини-играх**

```css
/* переключение состояния */
#toggle:checked + label { background: #def; } /* сосед label */
#toggle:checked ~ .panel { display: block; }  /* все следующие элементы */

/* подсветка только прямых клеток лабиринта */
.lab > .wall:hover { background: #333; }

/* влияние на потомков любого уровня */
.lab .wall:hover { background: red; }
```




### Что надо сделать:

#### Лабиринт
![2025-10-11 15-27-56.gif](./assets/2025-10-11%2015-27-56.gif)

#### Поиск сокровищ
![2025-10-11 15-27-5.gif](./assets/2025-10-11%2015-32-31.gif)
